\documentclass[letterpaper, reqno, 11pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{color,latexsym,amsmath,amssymb}
\usepackage{fancyhdr}
\usepackage{changepage}
\usepackage{algorithm2e}
\SetKwComment{Comment}{}{}
\pagestyle{fancy}
\newcommand{\ttitle}{Parallel Heapify}
\newcommand{\tname}{jacketsj}
\lhead{\ttitle}
\rhead{\tname}
\cfoot{\thepage}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\NN}{\mathbb{N}}

\begin{document}

\title{\ttitle}
\author{\tname}

\maketitle

\section*{Overview}
\subsection*{Basic background information}
\indent A heap is a nearly complete binary tree used for priority queues that satisfies the heap property: All nodes are greater than their children.
In particular, a heap is (in this case), represented as an array, with the node at index $i$'s children stored at indeces $2i+1$ and $2i+2$.
To "heapify" an array means to generate a permutation of an array meeting the heap property, when interpreted as a heap stored as an array.\\
\subsection*{The algorithm}
\indent This parallel implementation of a heapify algorithm runs in $\Theta(\log n)$ span, but with $\Theta(2^n)$ work, where $n$ is the size of the input array.\\
\indent The algorithm functions by completing a series of subproblems in parallel, and then using compiling some of the results.
Specifically, the algorithm finds the maximum of every single subset of the array, and then determines the left and right subheaps in that subset.
These two sets of results are easily compiled into a heap with a recursive subroutine.

\section*{Pseudocode}

\subsection*{Parallel Heapify}
\begin{algorithm}[H]
\caption{pHeapify}
\KwData{Integer Array $A[]$, int $n$ (size)}
\KwResult{Integer Array meeting the Heap Properties that is a permutation of $A$}
\If(\tcp*[f]{Parallelization useless in base case}){$n\leq1$}
{
	\Return a copy of $A$\;
}
int $C_\#:=exp(2, n)$\tcp*{Number of threads/combinations (combination number)}
Integer Array $powLookup[n]$\;
$Map(powLookup[i]:=exp(2,i),n)$\tcp*{Map runs threads in parallel for every $0\leq i<n$}
Integer Array $arr\_max[C_\#]$\tcp*{The maximum value location in every combination}
$Map(arr\_max[i]:=max\_loc(A,0,n-1,i,powLookup).index, C_\#)$\;
Integer Arrays $arr\_count[C_\#]$, $arr\_left[C_\#]$, $arr\_right[C_\#]$, $arr\_mids[C_\#]$\;
Subroutine $SubheapCount(i)$:
\begin{description}
	\item{}
	$arr\_count[i]:=count(0,n-1,i,powLookup)$\;
	int $sub:=\frac{arr\_count[i]-1}{2}$\;
	Round $sub$ down to nearest power of two minus $1$
	(number that is all $1$s in binary) with binary search\;
	int $remainder:=\max(arr\_count[i]-2\times sub-1,0)$
	\tcp*{Leaf nodes that are at the uncompleted depth}
	$rem:=\min(rem,\left\lceil\frac{arr\_count[i]-rem}{2}\right\rceil$)
	\tcp*[f]{Remainder extends beyond left subtree}
	$mids[i]:=sub+rem$\tcp*{Count of left subtree}
\end{description}
$Map(SubheapCount(i), C_\#)$\;
Subroutine $SubheapFind(i)$:
\begin{description}
	\item{}
	int $maxPos:=powLookup[arr\_max[i]]$
	\tcp*{The position of the maximum}
	int $midCount:=mids[i]$\tcp*{Count to mid in this combination}
	Do binary search to find the minimum $k$ such that
	$arr\_count[((powLookup[k]-1)\ \&\ (\neg maxPos))]\geq midCount$
	\tcp*{This finds the until the actual mid position in a particular combination}
	int $midloc:=powLookup[k]-1$\tcp*{The left subtree filter}
	$arr\_right[i]:=i\ \$\ (midloc)\ \$\ (\neg maxPos)$\;
	$arr\_left[i]:=i\ \$\ (\neg midloc)\ \$\ (\neg maxPos)$\;
\end{description}
$Map(SubheapFind(i), C_\#)$\;
Integer Array $R[n]$\;
$CompleteHeap(R, n, arr\_max, arr\_left, arr\_right, 0, C_\#-1, A)$\;
\Return $R$\;
\end{algorithm}

\subsection*{Exponent}
\begin{algorithm}[H]
\caption{exp}
\KwData{Integer $b$ (base, passed by value), Integer $k$ (exponent, passed by value)}
\KwResult{$b^k$}
\tcp{Simple doubling algorithm}
int $r:=1$\tcp*{Return value}
\While{$k>0$}
{
	\If{$k\nmid2$}
	{
		$r:=r\times b$\;
	}
	$k:=\left\lfloor\frac{k}{2}\right\rfloor$\;
	$b:=b^2$\;
}
\Return $r$\;
\end{algorithm}

\subsection*{Location of Maximum}
\begin{algorithm}[H]
\caption{max\_loc}
\KwData{Integer Array $A$, int $f$ (partition low index), int $h$ (partition high index),
		int $c$ (combination number), Array $P$ (powers of two)}
\KwResult{(value,index)}
\If(\tcp*{No more valid values for this combination}){$f>h\lor(f=h\land c\&P[f]\neq P[f])$}
{
	\Return $(-\infty,\infty)$\;
}
\If{$h=f$}
{
	\Return $(A[f],f)$\;
}
\tcp*{Divide and Conquer}
Create int left, right\;
\tcp*{Recurse in Parallel}
\begin{description}
	\item{(left)} $left:=Recurse(A,f,f+\left\lfloor\frac{f+h}{2}\right\rfloor,c,P)$\;
	\item{(right)} $right:=Recurse(A,f+\left\lfloor\frac{f+h}{2}\right\rfloor+1,h,c,P)$\;
\end{description}
\If{$left.value=right.value$}
{
	\eIf{$left.index<right.index$}
	{
		\Return $left$\;
	}
	{
		\Return $right$\;
	}
}

\If{$left.value>right.value$}
{
	\Return $left$\;
}
\Return $right$\;
\end{algorithm}

\subsection*{Count}
\begin{algorithm}[H]
\caption{count}
\KwData{int $f$ (partition low index), int $h$ (partition high index),
		int $c$ (combination number), Array $P$ (powers of two)}
\KwResult{int (count)}
\If(\tcp*{No more valid values for this combination}){$f>h\lor(f=h\land c\&P[f]\neq P[f])$}
{
	\Return 0\;
}
\If{$h=f$}
{
	\Return 1\;
}
Create int left, right\;
Recurse in Parallel:
\begin{description}
	\item{(left)} $left:=Recurse(f,f+\left\lfloor\frac{f+h}{2}\right\rfloor,c,P)$\;
	\item{(right)} $right:=Recurse(f+\left\lfloor\frac{f+h}{2}\right\rfloor+1,h,c,P)$\;
\end{description}
\Return $left+right$\;
\end{algorithm}

\subsection*{Completing the Heap}
\begin{algorithm}[H]
\caption{CompleteHeap}
\KwData{Array ref $H$, int $n$ (size), Array $arr\_max$,
		Array $arr\_left$, Array $arr\_right$,
		int $i$ (index), int $c$ (combination number), Array $A$}
\KwResult{int (count)}
\If(\tcp*{Beyond heap bounds or empty combination}){$i>n\lor c=0$}
{
	\Return 0\;
}
$H[i]:=A[arr\_max[c]]$\tcp*{Add maximum remaining to heap}
Recurse in Parallel:
\begin{description}
	\item{(left)} $left:=Recurse(H, n, arr\_max, arr\_left, arr\_right,
			2i+1, arr\_left[c], A)$\;
	\item{(right)} $right:=Recurse(H, n, arr\_max, arr\_left, arr\_right,
			2i+1, arr\_right[c], A)$\;
\end{description}
\end{algorithm}

\section*{Proof of Correctness}
\begin{description}
	\item{Exponent:}
	Lemma: Exponent returns $b^k$\\*
	Proof by induction on $k$:\\*
	Base Case: $k=0$\\*
		Then the loop never iterates, so the procedure correctly returns $b^0=1$.\\*
	Induction Step:	The loop correctly produces the answer for the last $i<k$ steps.\\*
	Consider the first step. If $k\nmid 2$, then $r$ is multiplied by $b$.\\*
	Then, by the induction hypothesis, the procedure correctly computes
	$r=r*(b^2)^{\left\lfloor\frac{k}{2}\right\rfloor}=b^{k-k\mod2}$.\\*
	Case 1: $k\mod 2=0$. In this case, since $r$ is not initially multiplied by $b$,
		at the end $r=1\times b^{k-0}=b^k$.\\*
	Case 2:	$k\mod 2=1$. In this case, since $r$ is initially multiplied by $b$,
		at the end $r=b\times b^{k-1}=b^{1+k-1}=b^k$.\\*
	Thus, the procudure is correct by the principle of induction.
\end{description}

\section*{Proof of (Parallel) Runtime}
Only parallel span will be analyzed:
\begin{description}
	\item{Exponent:}
		Since $k$ is halved at every step, and all other operations internally run at $O(1)$,
		the procedure runs in $O(\log k)$ time.
	\item{Location of Maximum, Count, Completion:}
		Let $n=h-f$ for a given input.\\*
		The runtime analysis for these three procedures are identical,
		since they all follow the same form.\\*
		Then, the runtime of this procedure runs under the recurrence relation
		$$T(n)=\max\left(T\left(\left\lfloor\frac{n}{2}\right\rfloor\right),
		+T\left(\left\lceil\frac{n}{2}\right\rceil\right)\right)+O(1),$$
		which is trivially solved to find $T(n)\in O(\log n)$.
	\item{SubheapCount:}
		Let $n$ be the input $n$.\\*
		All operations other than the binary search and count should run in $O(1)$ time,
		so the overall runtime should be $O(\log n)$,
		since the the binary search runs in $O(\log n)$ time even in a poor implementation
		(it can be even better with good bounds).
	\item{SubheapFind:}
		Similarly to SubheapCount, the binary search is the limiting factor,
		which can run in $O(\log n)$ time at worst.
	\item{Parallel Heapify:}
		In addition to several $O(1)$ calls, this procedure consists several calls:
		\begin{description}
			\item{Exponent:} The first call runs in $O(\log n)$ time,
			and following set of $n$ parallel calls all each run in $O(\log n)$ time,
			so the as a whole the operations run in $O(\log n)$ time.
			\item{Location of Maximum:} $2^n$ parallel calls each run in $O(\log n)$ time,
			so as a whole the operations run in $O(\log n)$ time.
			\item{SubheapCount:} $2^n$ parallel calls each run in $O(\log n)$ time,
			so as a whole the oeprations run in $O(\log n)$ time.
			\item{SubheapFind:} $2^n$ parallel calls each runi n $O(\log n)$ time,
			so as a whole the oeprations run in $O(\log n)$ time.
			\item{Complete:} A single call runs in $O(\log n)$ time.
		\end{description}
		Since a bounded, finite number of calls each run in $O(\log n)$ time,
		the procedure as a whole runs in $O(\log n)$ time.
\end{description}

\end{document}

