\documentclass[letterpaper, reqno, 11pt]{article}
\usepackage[margin=1.0in]{geometry}
\usepackage{color,latexsym,amsmath,amssymb}
\usepackage{fancyhdr}
\usepackage{changepage}
\usepackage{algorithm2e}
\SetKwComment{Comment}{}{}
\pagestyle{fancy}
\newcommand{\ttitle}{Parallel Heapify}
\newcommand{\tname}{jacketsj}
\lhead{\ttitle}
\rhead{\tname}
\cfoot{\thepage}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\NN}{\mathbb{N}}

\begin{document}

\title{\ttitle}
\author{\tname}

\maketitle

\section*{Overview}
\subsection*{Basic background information}
\indent A heap is a nearly complete binary tree used for priority queues that satisfies the heap property: All nodes are greater than their children.
In particular, a heap is (in this case), represented as an array, with the node at index $i$'s children stored at indeces $2i+1$ and $2i+2$.
To "heapify" an array means to generate a permutation of an array meeting the heap property, when interpreted as a heap stored as an array.\\
\subsection*{The algorithm}
\indent This parallel implementation of a heapify algorithm runs in $\Theta(\log n)$ span, but with $\Theta(2^n)$ work, where $n$ is the size of the input array.\\
\indent The algorithm functions by completing a series of subproblems in parallel, and then using compiling some of the results.
Specifically, the algorithm finds the maximum of every single subset of the array, and then determines the left and right subheaps in that subset.
These two sets of results are easily compiled into a heap with a recursive subroutine.

\section*{Pseudocode}

\subsection*{Parallel Heapify}
\begin{algorithm}[H]
\caption{pHeapify}
\KwData{Integer Array $A[]$, int $n$ (size)}
\KwResult{Integer Array meeting the Heap Properties that is a permutation of $A$}
\If(\tcp*[f]{Parallelization useless in base case}){$n\leq1$}
{
	\Return a copy of $A$\;
}
int $C_\#:=exp(2, n)$\tcp*{Number of threads/combinations (combination number)}
Integer Array $powLookup[n]$\;
$Map(powLookup[i]:=exp(2,i),n)$\tcp*{Map runs threads in parallel for every $0\leq i<n$}
Integer Array $arr\_max[C_\#]$\tcp*{The maximum value location in every combination}
$Map(arr\_max[i]:=max\_loc(A,0,n-1,i,powLookup).index, C_\#)$\;
Integer Arrays $arr\_count[C_\#]$, $arr\_left[C_\#]$, $arr\_right[C_\#]$, $arr\_mids[C_\#]$\;
Subroutine $SubheapCount(i)$:
\begin{description}
	\item{}
	$arr\_count[i]:=count(0,n-1,i,powLookup)$\;
	int $sub:=\frac{arr\_count[i]-1}{2}$\;
	Round $sub$ down to nearest power of two minus $1$
	(number that is all $1$s in binary) with binary search\;
	int $remainder:=\max(arr\_count[i]-2\times sub-1,0)$
	\tcp*{Leaf nodes that are at the uncompleted depth}
	$rem:=\min(rem,\left\lceil\frac{arr\_count[i]-rem}{2}\right\rceil$)
	\tcp*[f]{Remainder extends beyond left subtree}
	$mids[i]:=sub+rem$\tcp*{Count of left subtree}
\end{description}
$Map(SubheapCount(i), C_\#)$\;
Subroutine $SubheapFind(i)$:
\begin{description}
	\item{}
	int $maxPos:=powLookup[arr\_max[i]]$
	\tcp*{The position of the maximum}
	int $midCount:=mids[i]$\tcp*{Count to mid in this combination}
	Do binary search to find the minimum $k$ such that
	$arr\_count[((powLookup[k]-1)\ \&\ (\neg maxPos))]\geq midCount$
	\tcp*{This finds the until the actual mid position in a particular combination}
	int $midloc:=powLookup[k]-1$\tcp*{The left subtree filter}
	$arr\_right[i]:=i\ \$\ (midloc)\ \$\ (\neg maxPos)$\;
	$arr\_left[i]:=i\ \$\ (\neg midloc)\ \$\ (\neg maxPos)$\;
\end{description}
$Map(SubheapFind(i), C_\#)$\;
Integer Array $R[n]$\;
$CompleteHeap(R, n, arr\_max, arr\_left, arr\_right, 0, C_\#-1, A)$\;
\Return $R$\;
\end{algorithm}

\subsection*{Exponent}
\begin{algorithm}[H]
\caption{exp}
\KwData{Integer $b$ (base, passed by value), Integer $k$ (exponent, passed by value)}
\KwResult{$b^k$}
\tcp{Simple doubling algorithm}
int $r:=0$\tcp*{Return value}
\While{$k>0$}
{
	\If{$k\nmid2$}
	{
		$r:=r\times b$\;
	}
	$k:=\left\lfloor\frac{k}{2}\right\rfloor$\;
	$b:=b^2$\;
}
\Return $r$\;
\end{algorithm}

\subsection*{Location of Maximum}
\begin{algorithm}[H]
\caption{max\_loc}
\KwData{Integer Array $A$, int $f$ (partition low index), int $h$ (partition high index),
		int $c$ (combination number), Array $P$ (powers of two)}
\KwResult{(value,index)}
\If(\tcp*{No more valid values for this combination}){$f>h\lor(f=h\land c\&P[f]\neq P[f])$}
{
	\Return $(-\infty,\infty)$\;
}
\If{$h=f$}
{
	\Return $(A[f],f)$\;
}
\tcp*{Divide and Conquer}
Create int left, right\;
\tcp*{Recurse in Parallel}
\begin{description}
	\item{(left)} $left:=Recurse(A,f,f+\left\lfloor\frac{f+h}{2}\right\rfloor,c,P)$\;
	\item{(right)} $right:=Recurse(A,f+\left\lfloor\frac{f+h}{2}\right\rfloor+1,h,c,P)$\;
\end{description}
\If{$left.value=right.value$}
{
	\eIf{$left.index<right.index$}
	{
		\Return $left$\;
	}
	{
		\Return $right$\;
	}
}

\If{$left.value>right.value$}
{
	\Return $left$\;
}
\Return $right$\;
\end{algorithm}

\subsection*{Count}
\begin{algorithm}[H]
\caption{count}
\KwData{int $f$ (partition low index), int $h$ (partition high index),
		int $c$ (combination number), Array $P$ (powers of two)}
\KwResult{int (count)}
\If(\tcp*{No more valid values for this combination}){$f>h\lor(f=h\land c\&P[f]\neq P[f])$}
{
	\Return 0\;
}
\If{$h=f$}
{
	\Return 1\;
}
Create int left, right\;
Recurse in Parallel:
\begin{description}
	\item{(left)} $left:=Recurse(f,f+\left\lfloor\frac{f+h}{2}\right\rfloor,c,P)$\;
	\item{(right)} $right:=Recurse(f+\left\lfloor\frac{f+h}{2}\right\rfloor+1,h,c,P)$\;
\end{description}
\Return $left+right$\;
\end{algorithm}

\subsection*{Completing the Heap}
\begin{algorithm}[H]
\caption{CompleteHeap}
\KwData{Array ref $H$, int $n$ (size), Array $arr\_max$,
		Array $arr\_left$, Array $arr\_right$,
		int $i$ (index), int $c$ (combination number), Array $A$}
\KwResult{int (count)}
\If(\tcp*{Beyond heap bounds or empty combination}){$i>n\lor c=0$}
{
	\Return 0\;
}
$H[i]:=A[arr\_max[c]]$\tcp*{Add maximum remaining to heap}
Recurse in Parallel:
\begin{description}
	\item{(left)} $left:=Recurse(H, n, arr\_max, arr\_left, arr\_right,
			2i+1, arr\_left[c], A)$\;
	\item{(right)} $right:=Recurse(H, n, arr\_max, arr\_left, arr\_right,
			2i+1, arr\_right[c], A)$\;
\end{description}
\end{algorithm}

\section*{Proof of Correctness}

\section*{Proof of Runtime}

\end{document}

